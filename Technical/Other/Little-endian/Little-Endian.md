# <center>小端序</center>
<center>计算机喜欢读取的字节顺序。</center>

“小端序”指的是计算机处理字节信息的顺序。

例如，这是一个[十六进制](../Hexadecimal/hexadecimal.md)数：
```
12345678
```
这是**小端序**中的相同数字：
```
78563412
```
计算机处理这个数字的方式与我们阅读**12345678**的方式相同，这只是读取同一件事的两种不同方式。

>比特币喜欢在某些数据中使用小端序格式，因此在处理代码时，通常必须将内容转换为小端序格式才能使它们正常工作。

## 这是如何运作的？
看一下这个数字：
```
12345678
```
当你从左到右阅读时，你首先从最高有效位开始（即从**10000000**开始，以**8**结束）。因此，当你在脑海中处理这个数字时，你可以说你是从**大端**开始处理的。

但是，如果你思考一下，从**小端**开始同样有道理。
```
87654321
```
在这种格式中，你从最低有效值开始，一直到最高有效值。

当然，这彻底改变了你习惯阅读数字的方式，但如果你是一台计算机，这可能是更合理的方式。这就是为什么许多计算机处理器采用“小端序”方式读取数据。

但等等，这仍然不同于最初的小端数的格式……

### 字节。
计算机以块的形式读取数据。更准确地说，它们以“字节”形式处理数据。

现在，1个字节只是计算机内存中的一些空间，可以容纳2个十六进制字符。因此，当你将数据反转为小端序时，实际上是逐个字节进行处理的：
```
Big Endian:
             +------+------+------+------+
Byte Number: |  0   |  1   |  2   |  3   |
             +------+------+------+------+
Data:        |  12  |  34  |  56  |  78  |
             +------+------+------+------+

Little-Endian:
             +------+------+------+------+
Byte Number: |  0   |  1   |  2   |  3   |
             +------+------+------+------+
Data:        |  78  |  56  |  34  |  12  |
             +------+------+------+------+
        
```

因此，通过每次反转2个字符（1个字节），得到了小端序的**12345678**：
```
78563412
```

>所以小端仍然在第一位，但你每次只获取小端的1个字节（而不仅仅是一个字符）。

**快速转换为小端序。**  
如果想快速将数据字符串转换为小端序，只需**交换每对字符（从右到左工作），然后反转字符串。**

例子  
```
12345678
```
交换每一对字符（从右边开始）...
```
21436587
```
整个倒过来...  
```
78563412
```

>这只是将字符串转换为小端序的快速方法。虽然它可以完成任务，但并不能帮助你理解数据实际上发生了什么。

这个工具做的事情和它一样：

>[Swap Endian](https://learnmeabitcoin.com/tools/swapendian) - 一个基本的工具，可以在小端序和大端序格式之间转换（反之亦然）。

## 为什么比特币使用小端序？

因为比特币是这样设计的。

这可能不是对用户最友好（或最受欢迎[^1]）的选择，但现代计算机几乎总是在内部使用小端序格式，因此这个决定是为了提高处理速度。[^2]

## 比特币中的小端序示例。

[交易数据](../../Transaction/Transaction%20Data/Transaction%20Data.md)中的大多数字段都采用小端序格式。

任何序列化交易的前4个字节（8个字符）告诉你该交易的版本号。
```
0100000001528dd30e90e54ff5321758214b86b344c1867140b44e49975934727051158a0a000000008b4830450221008e332006edbbbda724f5955f55e29ec1dd526f9a7f7599b5c801860b3e378e4e02201c3f501bf1f43010e85a25abbd0fc4547491c334744cc4728d86914a59811dd4014104212b6993b785b677e55a886f9353b1d216c939c86b96d5d86e8f3bd8d8ffe2164ecf7c0f6ecc8c525a4850f896af1a7612fb7520ad88f77717ee4c824ab00582ffffffff01f06c3577000000001976a914d1a4db47565243b566b5fc400ff59400ac254cb988ac00000000
```
```
010000000 = version number (little-endian)
000000001 = version number (big-endian)
```
换句话说，这个交易的格式是**版本1**。

>记住，当从小端转换为大端时，先交换每一对字符，然后再反转字符串。

## 代码

### Bash
以下是如何在命令行上交换字节序（使用[grep](https://linux.die.net/man/1/grep)匹配每2个字符，[tac](https://linux.die.net/man/1/tac)反转顺序，然后使用[tr](https://linux.die.net/man/1/tr)删除换行符以得到字符串）：
```
echo 12345678 | grep -o .. | tac | echo $(tr -d '\n')
```

### PHP
这是一个类似的方法在PHP中（再次每2个字符切换）：[^3]
```php
// converts a string to little-endian
$string = 12345678;
$little-endian = implode('', array_reverse(str_split($string, 2)));
echo $little-endian;
```

### GIF
![little-endian-1.png](img/Little-Endian-1%20(1).gif)

## 资源
* [小端和大端转换](http://phoxis.org/2010/01/28/little-big-endian-conversion/)
* [大端和小端概述](http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html)


[^1]:[你会改变比特币网络的什么？](https://bitcointalk.org/index.php?topic=4278.0)
[^2]:[为什么比特币使用小端序？](http://bitcoin.stackexchange.com/questions/2063/why-does-the-bitcoin-protocol-use-the-little-endian-notation#answer-2069)
[^3]:[在PHP中更改字节序](http://stackoverflow.com/questions/7547056/changing-endianness-in-php#answer-7548355)