# <center>输出锁定</center>
<center>比特币批次的锁定机制。</center>

## 什么是输出锁定？
输出锁是对[输出](../Outputs.md)设置的一组要求。必须满足这些要求才能在交易中使用输出。

例如，最常见的输出锁定是这样的：

![Output%20Locks-1.png](img/Output%20Locks-1%20(1).png)

正是这些锁定机制防止在交易中花费彼此的输出，因为我们接收到的每个输出都被锁定机制所限制。

## 输出锁定来自哪里？
众所周知，交易是从现有的输出中创建新的输出的过程：

![Output%20Locks-2.png](img/Output%20Locks-2%20(1).png)

一笔交易。

在创建这些输出时，为每个输出设置了“锁定”。

![Output%20Locks-3.png](img/Output%20Locks-3%20(1).png)  

创建新的输出并为每个输出设置一个锁。

因此，当想要向朋友发送比特币时，需要创建新的输出，并添加一个锁定，该锁定表示“只有**1friend1234567890**的所有者可以使用此输出”。

![Output%20Locks-4.png](img/Output%20Locks-4%20(1).png)

所有这些都存储在交易数据中。

因此，这个新的输出实际上将“属于”我们的朋友，因为他们是唯一拥有此地址的私钥的人，所以其他人无法使用它.  
>你可能已经注意到，你从来没有在交易中真正“发送”比特币。  
相反，你正在构建一个创建新输出（带有新锁）的交易，将该交易数据发送到比特币网络，并等待它被挖掘到区块链中。

![Output%20Locks-5.png](img/Output%20Locks-5%20(1).png)

尽管区块链是交易文件，但在实际应用中，可以将其视为输出的存储单元。

![Output%20Locks-6.png](img/Output%20Locks-6%20(1).png)

每笔交易都会告诉你关于新输出的信息。  
当你想要将“你的”比特币发送给某人时，只需引用区块链中你能够解锁的输出即可：

![Output%20Locks-7.png](img/Output%20Locks-7%20(1).png)

当这笔交易被记录在区块链中时，你使用的输出（作为输入）将无法再次使用。

![Output%20Locks-8.png](img/Output%20Locks-8%20(1).png)

每个新的交易块都会向区块链中添加一批新的输出。  
区块链存储了所有的输出，你可以随时使用其中任何一个输出。  
当然，只要你能够解锁它们。

## 如何创建输出锁定？
输出锁定是用称为 SCRIPT 的基本编程语言编写的。

使用一个图片来解释整个编程语言的工作原理有点棘手，但我们还是来试着解释一下：  

![Output%20Locks-9.png](img/Output%20Locks-9%20(1).png)  

我们编写的这个锁被称为锁定脚本。

现在，这个锁定脚本中最有趣的部分是**CHECKPRIVATEKEY**，它是用来帮助​​设置锁定要求的**函数**。

因此，对于这个特定的输出，我们设置了一个要求使用私钥与地址**1EUXSxuUVy2PC5enGXR1a3yxbEjNWMHuem**进行比较的锁。

如果能提供这个锁匹配的私钥，就可以解锁它并在交易中使用它。

## 如何解锁输出锁定？
在构建交易数据时，你可以在要使用的每个输出后添加一个“解锁脚本”： 

![Output%20Locks-10.png](img/Output%20Locks-10%20(1).png)

例如，要解锁典型的锁定脚本（例如 **[address][CHECKPRIVATEKEY]**），需要证明我们拥有地址[address]。为此，我们使用私钥创建数字签名。

![Output%20Locks-11.png](img/Output%20Locks-11%20(1).png)  

你把你的数字签名作为“解锁脚本”。

当节点接收到这个交易数据时，它们将运行“锁定”+“解锁”脚本，以查看数字签名是否与输出所锁定的地址相匹配。

![Output%20Locks-12.png](img/Output%20Locks-12%20(1).png)  

如果一切顺利，节点会接受交易并将其传递给其他节点，其他节点将在接受交易之前都会运行“锁定”+“解锁”脚本。

这就是解锁输出锁定的方法。

## 什么鬼？我们正在泄露我们的私钥！

敏锐的观察，先生。

>**坦白说：实际上并没有将私钥放入交易数据中。**

你看，为了避免在交易数据中泄露私钥，我们创建了一种叫做“数字签名”的东西：

![Output%20Locks-13.png](img/Output%20Locks-13%20(1).png)

使用私钥创建数字签名。

显然我对使用的那个功能也撒了谎。但是不用担心，实际上有一个比较 **[地址]**和 **[数字签名]**的函数，它被称为**CHECKSIG**。  

![Output%20Locks-14.png](img/Output%20Locks-14%20(1).png)  

仍然有效。

由于数字签名和**CHECKSIG**功能的神奇作用，我们仍然可以将输出锁定到地址，并能够在不泄露私钥的情况下解锁它们。

非常棒。